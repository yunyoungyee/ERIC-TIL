### #️⃣ 명시적 바인딩

가끔 this를 우리가 원하는 객체로 강제로 지정하고 싶을때가 있음 → call, apply, bind 메소드를 사용할 수가 있다. 모든 함수가 갖고 있는 기존 내장 메소드입니다.

##### call / apply
###### 이 두개의 메소드는 함수 호출하면서 this가 될 객체를 첫번째 인자로 넘겨주면 된다. 즉시 그 함수를 실행시킨다라는 공통점을 갖고 있다.

🔴 **call**
-> this로 사용할 객체, 함수에 전달할 인자 쉼표로 구분
즉시 실행되며, this를 직접 지정하는 방식을 쓰고, `fn.call(obj,1,2)` 이렇게 쓴다.
```jsx
function sayHello(age) {
    console.log(`안녕, 나는 ${this.name}이고 ${age}살이야`);
}
        
const user = { name: '윤영' };
sayHello.call(user, 27); // ✅ this → user
// 함수.call(this로_쓸_객체, arg1, arg2, ...);
```
        
🔴 **apply**
-> this로 사용할 객체, 함수에 전달할 인자 배열형태로 묶어서 넘긴다.
즉시 실행되며, this를 직접 지정하는 방식을 쓰고, `fn.apply(obj,[1,2])` 이렇게 쓴다.
        
```jsx
function sayHello(age, city) {
    console.log(`안녕, 나는 ${this.name}, ${age}살이고 ${city}에 살아`);
}
        
const user = { name: '윤영' };
sayHello.apply(user, [27, '서울']); // ✅ call과 동일하지만, 배열로 전달
// 함수.apply(this로_쓸_객체, [arg1, arg2, ...]);
```
        
🔴 **bind**
-> 함수 즉시 실행하지 않고 this가 영구적으로 고정된 새로운 함수를 반환한다. 
콜백함수에서 this 컨텍스트를 잃어버리는 문제를 해결할 때 쓸 수 있다.
나중에 실행되며, this를 고정 함수로 반환하고, `const f = fn.bind(obj)` → `fn()` 이렇게 쓴다.
```jsx
function greet() {
	console.log('Hi, I am ${this.name}.');
}

const user = { name: 'thor' };
const userGreet = greet.bind(user):
userGeet(); // Hi, i am thor
```

### ❓ 클로저가 가능한 이유?

함수가 생성될 때, 자신이 선언된 위치의 렉시컬 환경을 [[Environment]] 내부 슬롯에 저장함.

##### 그렇다면 실행 컨텍스트와 [[Environment]]는 무슨 관계일까?

->함수가 실행될 때, 자바스크립트 엔진은 새로운 실행 컨텍스트를 만드는데 이 실행 컨텍스트 안에는 외부 환경 참조(Outer Environment Reference) 라는 게 들어있음.

그래서, 

1️⃣ 함수가 생성될 때, 엔진은 이 함수가 선언된 렉시컬 환경을 기억하고(상위 스코프 기억)

2️⃣ 이걸 [[Environment]] 내부 슬롯에 저장함. 그리고서

3️⃣ 함수가 실행될 때, 새로운 실행 컨텍스트를 만들고 

4️⃣ 그 안에 있는 외부 환경 참조(Outer Environment Reference)를 [[Environment]] 이 슬롯이 가리키는 환경으로 설정하는 것!

정리

```jsx
[[Environment]] (함수가 선언될 때 → 상위 스코프 기억)
↓
Outer Environment Reference (함수가 실행될 때 → 상위 스코프 연결)
```