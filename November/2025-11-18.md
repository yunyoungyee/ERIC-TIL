## Spring Security - 인가 흐름

### 사용 방법

### URL 기반 보안 (선언적 권한 부여)

규칙들은 위에서 순서대로 적용이 됩니다. → 가장 먼저 매칭되는 규칙이 적용되고 끝난다.

`.anyRequest().authenticated()` 를 맨 위에 적는다면? → 모든 요청이 이 규칙에 먼저 걸리기 때문에 아래에 있는 규칙들은 적용이 안 될수가 있다

<aside>
❓

뭐가 문제일까?

규칙이 걸려서 적용되게 되면 그 규칙을 적용하고 종료를 해버림. 
그러면 예를 들어 로그인을 할 때 ADMIN을 구분해야하는데 `.anyRequest().authenticated()` 다음으로 `requestMatchers("/admin/**").hasRole("ADMIN")` 오게되면 확인을 하지 않습니다.

</aside>

→ 또한 만약 아래에 /login permitall() 해두면 로그인페이지 조차 접근 할 수없는 상황이 생길 수가 있다
(로그아웃하고 인증이 안 된 상태에서 로그인을 하러 가야하는데? 인증이 없어서 계속 접근을 못하는 무한 루프가 걸림)
→ 규칙 선언할 때 항상 순서를 생각해서 하자

<aside>
❓

### hasRole(”ADMIN”)과 hasAuthority(”ROLE_ADMIN”)은 똑같은 건가요?

- **hasRole("ADMIN")** : 내부적으로 “ROLE_ADMIN” 권한이 있는지 확인. 스프링 시큐리티가 역할이라는 개념을 표현하기 위해 자동으로 "ROLE_” 접두사를 붙여준다.
- **hasAuthority("ROLE_ADMIN")** : 접두사까지 포함해서 정확히 일치하는 권한이 있는지 확인하는것

역할 기반으로 hasRole로 나눈 다음에 특정 기능에 대한 세밀한 제어가 필요할때는 hasAuthority를 사용한다.  어드민 역할지만 글쓰기, 글삭제, 댓글쓰기 권한이 있는데 어드민은 글을 쓸 필요가 없다라고 하면 글쓰기 권한에 대해서 관리를 하기 위함.

*스프링 시큐리티 관례상 권한을 정의할 때는 ROLE을 붙여야 한다고 함. 그래서 ADMIN만 써서 hasAuthority(”ROLE_ADMIN”)에서 접근을 못하는 경우가 없을 것 같음

</aside>

## CORS
### Spring Security로 설정해야하는 이유?
왜? → 시큐리티 필터체인 생각해보면 요청 들어오면 디스패처서블릿 도달하기 전까지 여러보안 필터들을 거친다 → 인증 실패하거나 하면 요청은 컨트롤러까지 못가고 필터단에 거부 

그런데, CORS 설정을 SpringMVC 레벨에만 해두면 인증 필터에서 거부된 요청에는 CORS 관련한 헤더가 응답에 포함되지 않을 수 있다
→ 왜냐면 필터는 Spring MVC 외부에서 동작하는데 CORS 설정을 Spring MVC에만 해두면 CORS 설정이 적용되기도 전에 막힘.

프론트엔드 입장에서는 서버가 응답을 주긴 줬는데 CORS 헤더가 자체가 없으니까 CORS 에러라고 판단해버릴수가 있다 → 백엔드에서는 인증 실패인데 프론트엔드에서는 CORS 에러로 보이는 헷갈리는 상황이 생긴다