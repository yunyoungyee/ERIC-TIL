##### 들어서며
데이터베이스 동시성 제어에 대한 내용 중 데드락에 대한 내용을 잡고 갔습니다.
운영체제와 헷갈리기도 했고, 동시성을 제어하는 방식이 비관적 vs 낙관적으로 구분을 할 수 있었습니다.

### 운영체제 데드락과 데이터베이스 데드락 차이 
- 데이터베이스는 트랜잭션에서 발생을 하고, 운영체제는 프로세스 또는 스레드에서 발생
- 데이터베이스는 논리적인 작업 취소가 목표이기 때문에 데이터를 지키면서 재시도를 하려고 하는데,
- 운영체제는 물리적인 자원을 해제하거나 프로세스 종료가 목표이기 때문에 작업 손실이 발생할 수 있음

### 동시성 제어 방식(비관적 락 기반)
- Lock-based Concurrency Control (락 기반 동시성 제어)
    - 트랜잭션이 데이터를 읽거나 변경하기 전에, 해당 데이터에 대한 접근 권한을 얻는 과정
    - 트랜잭션이 자원을 사용하기 전, 충돌을 사전에 예방하기 위해 락을 검
- 2PL (Two-Phase-Locking)
    - 모든 트랜잭션이 락을 획득하고, 모든 트랜잭션이 락을 해제하는 단계를 구분
    - 락을 점유한 상태에서 다른 락을 기다릴 수 있도록 허용하기 때문에 
    데드락 발생 (순환 대기)
- Strict 2PL
    - 트랜잭션이 커밋 또는 롤백 전까지 락 해제 안함
    - 락 해제를 늦게하다보니 락을 오랫동안 점유해서 데드락 발생 빈도 높임

### 동시성 제어 방식
- Timestamp-based Concurrency Control (타임스템프 기반 동시성 제어)
    - (락 사용X) 타임스탬프를 부여해서 최신 데이터를 판별하고 충돌 관리
    - 타임스탬프로 트랜잭션의 유효성을 판단하고 유효하지 않다면 
    즉시 트랜잭션 중단(Abort)
- Multiversion Concurrency Control (MVCC)
    - 데이터의 여러 버전을 관리하여 트랜잭션 간 충돌 방지
    - 데이터를 수정할 때는 새로운 버전의 데이터 생성, 
    - 데이터를 읽을 때는 읽기 트랜잭션에게 이전 버전 데이터를 읽도록 허용
    - MVCC는 격리성이 지켜지고 있고 내부 로직 관점에서는 정합성도 지켜지고 있음 그러나 비즈니스 관점으로는 일관성이 깨졌다고 볼 수 있음.
### 왜 일관성이 깨졌다 볼 수 있을까?
    예시. 물품구매 (수량 1개 남아있는 상황)
    내부 로직으로는 다른 버전 관리를 하니까 A트랜잭션의 수행으로 재고가 0개로 줄어들고 B트랜잭션은 재고가 1인 버전을 읽었지만, 실제로 구매로 이어질때는 재고가 0개로 수정되어 있어서 문제가 생기지 않음.
    그러나 사용자에게 보여주는 비즈니스 관점에서는 1개 있다고 했는데 막상 사용자가 사지 못했으니 일관성 문제로 볼 수 있음.

