JPA 연관관계, 아직도 '그냥' 사용하시나요?

당신이 놓치고 있던 4가지 함정

JPA와 같은 ORM(Object-Relational Mapping) 은 우리 백엔드 개발자들에게 축복과도 같습니다.
객체와 데이터베이스라는 두 세계 사이의 복잡한 간극을 메워주며,
SQL 쿼리 없이도 객체지향적인 코드로 데이터를 다룰 수 있게 해주었죠.
그 덕분에 생산성은 극적으로 향상되었습니다.

누구나 한 번쯤은

“분명 코드는 문제없는데 왜 데이터가 이상하게 들어가지?”
“로컬에서는 빨랐는데 왜 테스트 서버에서는 이렇게 느리지?”

와 같은 의문을 품어본 경험이 있을 겁니다.
그 원인의 상당수가 바로 이 ‘연관관계’ 에 도사리고 있습니다.

하지만 이 편리함이라는 달콤함 뒤에는,
제대로 이해하지 않고 사용했을 때 마주할 수 있는 날카로운 함정들이 숨어 있습니다.
특히 여러 엔티티를 엮어주는 연관관계 매핑은
JPA의 가장 강력한 기능인 동시에,
가장 많은 성능 문제와 예기치 못한 오류를 일으키는 주범이 되기도 합니다.

이 글에서는 많은 개발자가 무심코 사용하다가 겪게 되는
JPA 연관관계의 4가지 핵심적인 함정을 파헤쳐 보겠습니다.

1️⃣ 단방향 @OneToMany는 왜 ‘안티패턴’으로 불릴까?

객체지향적으로 생각하면 User가 자신이 작성한 List<Post>를 갖는 것은 매우 자연스러워 보입니다.
그래서 많은 개발자들이 아래와 같이 User 엔티티에서 Post 엔티티로의 단방향 @OneToMany 관계를 설정하곤 합니다.

@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany
    @JoinColumn(name = "user_id") // Post 테이블에 FK 컬럼(user_id) 생성
    private List<Post> posts = new ArrayList<>();
}

@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;
    private String title;
}


하지만 이 설계는 실무에서 피해야 할 안티패턴으로 꼽힙니다.
가장 큰 이유는 ‘관리 주체의 불일치’ 문제 때문입니다.

관계형 데이터베이스에서 외래 키(user_id)는 post 테이블에 존재합니다.

하지만 위 코드에서는 외래 키가 없는 User 엔티티가 post 테이블의 외래 키 값을 관리해야 하는 이상한 상황이 발생합니다.

이 구조는 심각한 성능 문제로 이어집니다.
새로운 게시글을 저장하는 상황을 예로 들어보겠습니다.

Post 객체를 생성하고 저장(persist)합니다.

JPA는 INSERT INTO post (...) VALUES (...) 쿼리를 실행합니다.
이때 Post는 User를 모르므로 user_id는 null인 상태로 저장됩니다.

개발자는 user.getPosts().add(newPost) 코드를 통해 User의 게시글 리스트에 새 게시글을 추가합니다.

트랜잭션이 커밋되는 시점, JPA는 연관관계의 주인인 User 엔티티의 posts 컬렉션에 변화가 생겼음을 더티 체킹으로 감지하고,
post 테이블의 user_id 컬럼을 채우기 위해 불필요한 UPDATE 쿼리를 추가로 실행합니다.

UPDATE post SET user_id = ? WHERE id = ?


결국 게시글 하나를 저장하는 데 INSERT + UPDATE 쿼리가 모두 실행됩니다.
만약 100개의 게시글을 한 번에 저장한다면,
100번의 불필요한 UPDATE 쿼리가 발생하게 되는 것이죠.

✅ 해결 방법:
연관관계의 주인은 여전히 외래 키를 가진 Post 테이블입니다.
따라서 단방향 @OneToMany 대신,
보통 양방향 @ManyToOne을 주인으로 둔 설계를 사용합니다.

2️⃣ ‘연관관계의 주인’, 진짜와 가짜를 구별해야 하는 이유

양방향 연관관계를 설정할 때
‘연관관계의 주인(Owner of the relationship)’이라는 개념은 매우 중요합니다.
이를 제대로 이해하지 못하면 데이터가 DB에 반영되지 않는 혼란스러운 상황을 겪게 됩니다.

객체 세계: User ↔ Post 서로 참조 가능

DB 세계: 외래 키는 post 테이블 한쪽에만 존재

이를 맞추기 위해 JPA는 ‘주인’ 개념을 도입했습니다.

💡 오직 ‘주인’으로 지정된 엔티티의 변경사항만 데이터베이스에 반영됩니다.

구분	설명
주인(Owner)	실제 외래 키를 가진 테이블과 매핑된 엔티티. 보통 @ManyToOne 쪽.
주인이 아닌 쪽(Non-owner)	mappedBy 속성을 사용해 “나는 주인이 아님”을 명시하는 쪽. 조회용 거울.

가장 중요한 사실은,

주인이 아닌 쪽에서 리스트에 객체를 추가하거나 삭제해도 데이터베이스에는 아무 변화도 없다는 점입니다.

// User.java (주인이 아님)
@OneToMany(mappedBy = "user")
private List<Post> posts = new ArrayList<>();

// Post.java (주인)
@ManyToOne
@JoinColumn(name = "user_id")
private User user;

// ❌ 잘못된 사용
user.getPosts().add(newPost); // post 테이블의 user_id가 채워지지 않음!

// ✅ 올바른 사용
newPost.setUser(user); // 주인인 Post에서 User를 설정해야 DB 반영


👉 외래 키가 있는 쪽이 ‘주인’이다.
이 원칙만 기억하면 데이터 반영 문제로 헤맬 일이 없다.

3️⃣ 지연 로딩(LAZY)은 N+1 문제의 해결책이 아니다

N+1 문제는 JPA에서 가장 흔한 성능 이슈입니다.
첫 쿼리로 N개의 결과를 가져온 뒤,
각 결과의 연관 데이터를 위해 N번의 추가 쿼리가 발생하는 현상이죠.

예시
List<User> users = em.createQuery("SELECT u FROM User u", User.class)
                     .getResultList();


만약 User ↔ Post 관계가 EAGER로 매핑되어 있다면,
위 한 줄의 조회로 각 User의 Post를 가져오기 위한 100번의 추가 쿼리가 발생할 수 있습니다.

많은 개발자들의 실수

이 문제를 피하려고 Fetch 전략을 LAZY로 바꿉니다.
하지만 이는 근본적인 해결책이 아닙니다.

LAZY는 단지 “나중에 필요할 때” 쿼리를 실행할 뿐

실제 데이터를 접근하는 순간 결국 N개의 쿼리가 나갑니다.

for (User user : users) {
    user.getPosts().size(); // 이 순간 N번의 추가 쿼리 발생!
}


✅ 진짜 해결책:

Fetch Join 을 사용해 처음부터 연관 데이터를 한 번의 쿼리로 함께 조회.

SELECT u FROM User u JOIN FETCH u.posts

4️⃣ 양방향 연관관계와 끝나지 않는 ‘뫼비우스의 띠’

양방향 연관관계는 또 다른 문제,
바로 JSON 직렬화(Serialization) 시 무한 순환 참조 문제를 일으킬 수 있습니다.

// User.java
@OneToMany(mappedBy = "user")
private List<Post> posts;

// Post.java
@ManyToOne
private User user;


User → Post → User → Post…
이 순환이 반복되며 StackOverflowError 발생!

💣 해결 방법

엔티티를 API 응답으로 직접 노출하지 말 것.

DTO(Data Transfer Object) 를 사용하여 필요한 데이터만 선별.

@JsonIgnore는 임시방편일 뿐, 근본 해결책이 아님.

DTO 사용은 단순히 오류를 피하는 걸 넘어,
도메인 모델과 API 스펙을 명확히 분리하여
시스템의 유연성과 유지보수성을 높여줍니다.

🧭 마치며

JPA의 연관관계 매핑은 객체지향적인 설계를 DB에 우아하게 반영할 수 있는
매우 강력하고 편리한 기능입니다.
하지만 그 편리함에 취해 내부 동작 원리를 이해하지 못하면,
숨겨진 성능 문제나 예기치 못한 오류를 맞닥뜨리게 됩니다.

오늘 살펴본 네 가지 함정만 피해도 JPA 코드는 훨씬 더 견고해집니다:

❌ 단방향 @OneToMany → 불필요한 UPDATE 유발

⚙️ 연관관계의 주인 혼동 → 데이터 반영 실패

🐢 LAZY만 믿고 N+1 방치 → fetch join으로 해결

🔁 양방향 순환 참조 → DTO로 분리

💬 오늘, 당신의 코드 속 연관관계는 안녕하신가요?