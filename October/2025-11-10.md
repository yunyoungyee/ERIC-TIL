# ✏️ 클로저와 렉시컬 스코프의 차이점

## 📘 렉시컬 스코프 (Lexical Scope)

- 자바스크립트가 변수를 **참조할 때 규칙을 정하는 방식**
- **함수가 어디서 선언되었는지**에 따라 상위 스코프가 **정적으로 결정**
- **자신을 둘러싼 외부 환경(스코프)**의 모든 변수와 함수를 **정적으로 기억**
- 함수가 **선언될 때 이미 외부 환경이 결정**됨

---

## 📗 클로저 (Closure)

- **렉시컬 스코프의 결과로 나타나는 특별한 현상**
- **함수가 외부로 반환된 후에도** 그 환경(스코프)에 **접근할 수 있는 메커니즘**
- 함수가 선언된 **외부 스코프를 함께 묶어서 기억**
- **외부 함수가 종료된 후에도** 해당 스코프가 **소멸되지 않고 유지**

---

## 📙 핵심 비교

| 구분 | 렉시컬 스코프 | 클로저 |
|------|----------------|---------|
| 개념 | 변수 참조 규칙 | 규칙으로 인한 현상 |
| 적용 대상 | 모든 함수 | 외부로 반환된 함수 |
| 시점 | 선언 시 결정 | 실행 후에도 지속 |
| 역할 | 외부 스코프 기억 | 외부 스코프에 계속 접근 가능 |

👉 **요약**  
렉시컬 스코프는 “모든 함수가 외부 환경을 기억하는 규칙”이고,  
클로저는 “그 규칙 덕분에 외부 함수가 끝나도 접근 가능한 현상”이다.

---

# ✏️ 디옵티마이제이션 (Deoptimization) 피하기

V8 엔진은 자바스크립트 코드를 **성능 좋게 최적화(optimization)** 하려 한다.  
하지만 특정 **안티 패턴**을 사용하면 이 최적화를 **거부(deoptimize)** 한다.

---

## ⚙️ 최적화 컴파일러

- 일종의 **패턴 인식 전문가**
- “일관된 패턴”을 감지해 빠른 기계어로 변환하지만,
- **예측 불가능한 코드 패턴**은 최적화를 **거부**

---

## ❌ 안티 패턴 1. 객체 형태를 동적으로 변경하기

V8 엔진은 객체의 구조(프로퍼티의 종류와 순서)가 동일한 객체를  
내부적으로 **셰이프(Shape)** 또는 **히든 클래스(Hidden Class)** 로 관리한다.  
같은 셰이프를 가진 객체는 빠르게 처리할 수 있다.

### ✔️ 올바른 방법

- **객체 생성 시 모든 속성을 동시에 정의**
  ```js
  const user = { name: "Alice", age: 30 };

## 🧩 안티 패턴 2. 다형성 남용 (Polymorphism Misuse)

```js
function add(a, b) {
  return a + b;
}

add(1, 2);
add(3, 4);

add("hello", "world");

add({}, []); // ❌ 최적화가 거의 불가능
